import numpy as np
from PIL import Image

class Mipmap:
    """
    A utility class to generate and store a Mipmap pyramid for a given image.

    The Mipmap levels are generated by repeatedly downscaling the image by a 
    factor of 2 using a 2x2 box filter (averaging).
    """

    def __init__(self, image: np.ndarray):
        """
        Initializes the Mipmap object and generates all Mipmap levels.

        Args:
            image (np.ndarray): The input image as a NumPy array. 
                                Expected shape is (height, width, channels).
                                The data type should be numerical (e.g., uint8, float).
        """
        if not isinstance(image, np.ndarray):
            raise TypeError("Input image must be a NumPy array.")

        self.levels = []
        self._generate_mipmap(image)

    def _generate_mipmap(self, image: np.ndarray):
        """
        Private method to build the Mipmap pyramid.
        """
        # Level 0 is the original image
        current_image = image.copy().astype(np.float32)
        self.levels.append(current_image.astype(image.dtype))

        while current_image.shape[0] > 1 or current_image.shape[1] > 1:
            downscaled_image = self._downscale_by_2(current_image)
            self.levels.append(downscaled_image.astype(image.dtype))
            current_image = downscaled_image

    def _downscale_by_2(self, image: np.ndarray) -> np.ndarray:
        """
        Downscales the image by a factor of 2 using 2x2 averaging.
        Handles odd dimensions by trimming the last row/column.
        
        Args:
            image (np.ndarray): The image to downscale (must be float type for averaging).

        Returns:
            np.ndarray: The downscaled image.
        """
        h, w, c = image.shape
        
        # Calculate new dimensions, ensuring they are integers
        new_h = max(1, h // 2)
        new_w = max(1, w // 2)

        # Trim the image to be of even dimensions
        trimmed_image = image[:new_h * 2, :new_w * 2]

        # Reshape and average
        # This is a highly efficient NumPy trick to average 2x2 blocks without loops.
        # (new_h, 2, new_w, 2, c) -> group pixels into 2x2 blocks
        # .mean(axis=(1, 3)) -> average over the 2x2 block axes
        downscaled = trimmed_image.reshape(new_h, 2, new_w, 2, c).mean(axis=(1, 3))
        
        return downscaled

    def get_level(self, level: int) -> np.ndarray:
        """
        Retrieves the image at a specific Mipmap level.

        Args:
            level (int): The Mipmap level to retrieve (0 is the original image).

        Returns:
            np.ndarray: The image at the specified level.
        
        Raises:
            IndexError: If the requested level is out of bounds.
        """
        if not 0 <= level < len(self.levels):
            raise IndexError(f"Invalid level {level}. Available levels are 0 to {len(self.levels) - 1}.")
        return self.levels[level]

    @property
    def num_levels(self) -> int:
        """Returns the total number of Mipmap levels."""
        return len(self.levels)

    def __len__(self):
        """Allows using len() on a Mipmap object."""
        return self.num_levels

    def __getitem__(self, level: int) -> np.ndarray:
        """
        Allows accessing Mipmap levels using slicing, e.g., mipmap[level].
        This is a more Pythonic way to access levels.
        """
        return self.get_level(level)
